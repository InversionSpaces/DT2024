\import Algebra.Meta
\import Data.Bool
\import Data.List
\import Data.Or
\import Meta
\import Paths
\import Paths.Meta
\import hw06
\import lect08
\import Order.LinearOrder
\open LinearOrder

-- 1. Реализуйте функцию filter и докажите ее корректность, то есть, что выполнены следующие условия:
--    * filter p xs является подсписком xs
--    * Все элементы filter p xs удовлетворяют предикату p
--    * Любой подсписок xs с тем же свойством является подсписком filter p xs

\func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
  | nil => nil
  | a :: xs => \case p a \with {
    | true => a :: filter p xs
    | false => filter p xs
  }

\func filter-sublist {A : \Type} (p : A -> Bool) (xs : List A) : Sublist (filter p xs) xs \elim xs
  | nil => NilSublist
  | a :: xs => mcases \with {
    | true => ConsSublist idp (filter-sublist p xs)
    | false => SkipSublist (filter-sublist p xs)
  }

\type ForAll {A : \Type} (p : A -> Bool) (xs : List A) => \Pi (a : A) -> In a xs -> So (p a)

\func filter-correct {A : \Type}
                     (p : A -> Bool)
                     (xs : List A) : ForAll p (filter p xs) \elim xs
  | nil => \lam _ in => \case in
  | a :: xs => cases (p a arg addPath) \with {
    | false, _ => filter-correct p xs
    | true, pa=t => lemma p a (rewrite pa=t ()) (filter p xs) (filter-correct p xs)
  }
  \where {
    \func lemma {A : \Type}
                (p : A -> Bool)
                (a : A)
                (pa : So (p a))
                (xs : List A)
                (fa : ForAll p xs) : ForAll p (a :: xs) =>
      \lam b bin => \case bin \with {
        | Found b=a => rewrite b=a pa
        | Later lin => fa b lin
      }
  }

\func filter-max {A : \Type}
                 {p : A -> Bool}
                 {xs ys : List A}
                 (sub : Sublist ys xs)
                 (fays : ForAll p ys) : Sublist ys (filter p xs) \elim xs, ys, sub
  | xs, nil, NilSublist => NilSublist
  | x :: xs, y :: ys, ConsSublist y=x sub => cases (p x arg addPath) \with {
    | true, _ => ConsSublist y=x (filter-max sub (\lam a i => fays a (Later i)))
    | false, px=f => \case rewrite (y=x,px=f) (fays y (Found idp))
  }
  | y :: xs, ys, SkipSublist sub => mcases \with {
    | true => SkipSublist (filter-max sub fays)
    | false => filter-max sub fays
  }

-- 2. Докажите, что Perm l1 l2 тогда и только тогда, когда Insertion.sort l1 = Insertion.sort l2.

\func perm-symm {A : \Type} {ls rs : List A} (p : Perm ls rs) : Perm rs ls \elim ls, rs, p
  | nil, nil, perm-nil => perm-nil
  | a :: ls, b :: rs, perm-:: p plsrs => perm-:: (inv p) (perm-symm plsrs)
  | ls, rs, perm-trans plsys pysrs => perm-trans (perm-symm pysrs) (perm-symm plsys)
  | a :: (an :: ls), b :: (bn :: rs), perm-swap a=bn an=b ls=rs => perm-swap (inv an=b) (inv a=bn) (inv ls=rs)

\func perm-sort {A : Dec} (ls rs : List A) : Perm ls rs <-> (Insertion.sort ls = Insertion.sort rs)
  => (forward, backward)
  \where {
    \func forward {A : Dec}
                  {ls rs : List A}
                  (p : Perm ls rs) : Insertion.sort ls = Insertion.sort rs
    \elim ls, rs, p
      | nil, nil, perm-nil => idp
      | a :: ls, b :: rs, perm-:: a=b plsrs => rewrite (a=b,forward plsrs) cong
      | ls, rs, perm-trans plsys pysrs => rewrite (forward plsys,forward pysrs) idp
      | a :: (an :: ls), b :: (bn :: rs), perm-swap a=bn an=b ls=rs =>
        rewrite (ls=rs,a=bn,an=b) (insert-comm bn b (Insertion.sort rs))
      \where {
        \open Insertion.sort (insert)
        \func insert-comm {A : Dec}
                          (a b : A)
                          (xs : List A) : insert a (insert b xs) = insert b (insert a xs) \elim xs
          | nil => mcases idp \with {
            | inl a<b, inl b<a => \case notLess (<_<= a<b) b<a
            | inr a<=b, inr b<=a => rewrite (LinearOrder.<=-antisymmetric b<=a a<=b) idp
          }
          | x :: xs => mcases \with {
            -- Делаю dec reduce 10 раз
            | inl x<b, inl x<a => rewrite (dec<_reduce x<a, dec<_reduce x<b) (pmap (:: x) (insert-comm a b xs))
            | inl x<b, inr a<=x => rewrite (dec<_reduce x<b, dec<=_reduce a<=x, dec<_reduce (LinearOrder.<∘r a<=x x<b)) idp
            | inr b<=x, inl x<a => rewrite (dec<=_reduce b<=x, dec<_reduce (LinearOrder.<∘r b<=x x<a), dec<_reduce x<a) idp
            | inr b<=x, inr a<=x => rewrite (dec<=_reduce b<=x, dec<=_reduce a<=x) (cases (dec<_<= a b) \with {
              | inl a<b => rewrite (dec<=_reduce (<_<= a<b)) idp
              | inr b<=a => mcases idp \with {
                | inr a<=b => rewrite (LinearOrder.<=-antisymmetric b<=a a<=b) idp
              }
            })
          }

        -- -- А эту лемму можно доказать? У меня не получилось
        --       \func lemma {A : Dec}
        --                   (ls rs : List A)
        --                   (lss : Sorted ls)
        --                   (rss : Sorted rs)
        --                   (p : Perm ls rs) : ls = rs
        --         | nil, nil, sorted-nil, sorted-nil, _ => idp
        --         | nil, a :: rs1, sorted-nil, sorted-:: _x rss, perm-trans p1 p2 => {?}
        --         | a :: ls1, nil, sorted-:: _x lss, sorted-nil, perm-trans p1 p2 => {?}
        --         | a :: ls, b :: rs, sorted-:: _ lss, sorted-:: _ rss, perm-:: a=b plsrs =>
        --           rewrite a=b (pmap (:: b) (lemma ls rs lss rss plsrs))
        --         | a :: ls, b :: rs, sorted-:: a<=hls lss, sorted-:: b<=hrs rss, perm-trans palsys pysbrs =>
        --           \case Dec
        --         | a :: (a1 :: ls1), b :: (b1 :: rs1), sorted-:: _x lss, sorted-:: _x1 rss, perm-swap p1 p2 p3 => {?}
        --     }
      }

    \func backward {A : Dec} {ls rs : List A} (p : Insertion.sort ls = Insertion.sort rs) : Perm ls rs =>
      perm-trans (Insertion.sort-perm ls) (rewrite p (perm-symm (Insertion.sort-perm rs)))
  }

-- 3. Докажите, что спецификация "результат является перестановкой входа и отсортирован" является полной для функции sort.

\func completeness {A : Dec} (sort : List A -> List A) (l : List A) (p : Perm l (sort l)) (s : Sorted (sort l)) : sort l = Insertion.sort l
  => rewrite ((perm-sort l (sort l)).1 p) (sort-lemma (sort l) s)
  \where {
    \func sort-lemma {A : Dec} (l : List A) (s : Sorted l) : l = Insertion.sort l
      | nil, sorted-nil => idp
      | a :: ls, sorted-:: a<=hls s => rewriteI (sort-lemma ls s) (insert-lemma a ls a<=hls)

    -- Не понял как разкрыть headDef прямо внутри sort-lemma, поэтому вынес в отдельную лемму
    \func insert-lemma {A : Dec} (a : A) (ls : List A)
                       (a<=hls : a <= headDef a ls) : a :: ls = Insertion.sort.insert a ls \elim ls
      | nil => idp
      | _ :: _ => rewrite (dec<=_reduce a<=hls) idp
  }

-- 4. Определите факториал через хвостовую рекурсию.
--    Докажите, что он равен обычному определению факториала.

-- 5. Функция isBalanced проверяет правильность скобочной последовательности.
--    Докажите ее корректность.

\data Paren | Left | Right

\func isBalanced (xs : List Paren) : Bool
  => aux xs 0
  \where {
    \func aux (xs : List Paren) (p : Nat) : Bool \elim xs, p
      | nil, 0 => true
      | nil, suc _ => false
      | Left :: xs, p => aux xs (suc p)
      | Right :: xs, 0 => false
      | Right :: xs, suc p => aux xs p
  }

\data Balanced (xs : List Paren) \with
  | nil => nil-balanced
  | :: Left xs => cons-balanced {ys : List Paren} (Balanced ys) (xs = ys ++ Right :: nil)
  | xs => append-balanced {ys zs : List Paren} (Balanced ys) (Balanced zs) (xs = ys ++ zs)

\func isBalanced-correct (xs : List Paren) : (isBalanced xs = true) <-> Balanced xs
  => {?}
