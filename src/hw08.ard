\import Data.Bool
\import Data.List \hiding (headDef)
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\import hw06
\import lect08
\import Order.LinearOrder
\open LinearOrder

-- 1. Реализуйте функцию filter и докажите ее корректность, то есть, что выполнены следующие условия:
--    * filter p xs является подсписком xs
--    * Все элементы filter p xs удовлетворяют предикату p
--    * Любой подсписок xs с тем же свойством является подсписком filter p xs

\func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
  | nil => nil
  | a :: xs => \case p a \with {
    | true => a :: filter p xs
    | false => filter p xs
  }

\func filter-sublist {A : \Type} (p : A -> Bool) (xs : List A) : Sublist (filter p xs) xs \elim xs
  | nil => NilSublist
  | a :: xs => mcases \with {
    | true => ConsSublist idp (filter-sublist p xs)
    | false => SkipSublist (filter-sublist p xs)
  }

\type ForAll {A : \Type} (p : A -> Bool) (xs : List A) => \Pi (a : A) -> In a xs -> So (p a)

\func filter-correct {A : \Type}
                     (p : A -> Bool)
                     (xs : List A) : ForAll p (filter p xs) \elim xs
  | nil => \lam _ in => \case in
  | a :: xs => cases (p a arg addPath) \with {
    | false, _ => filter-correct p xs
    | true, pa=t => lemma p a (rewrite pa=t ()) (filter p xs) (filter-correct p xs)
  }
  \where {
    \func lemma {A : \Type}
                (p : A -> Bool)
                (a : A)
                (pa : So (p a))
                (xs : List A)
                (fa : ForAll p xs) : ForAll p (a :: xs) =>
      \lam b bin => \case bin \with {
        | Found b=a => rewrite b=a pa
        | Later lin => fa b lin
      }
  }

\func filter-max {A : \Type}
                 {p : A -> Bool}
                 {xs ys : List A}
                 (sub : Sublist ys xs)
                 (fays : ForAll p ys) : Sublist ys (filter p xs) \elim xs, ys, sub
  | xs, nil, NilSublist => NilSublist
  | x :: xs, y :: ys, ConsSublist y=x sub => cases (p x arg addPath) \with {
    | true, _ => ConsSublist y=x (filter-max sub (\lam a i => fays a (Later i)))
    | false, px=f => \case rewrite (y=x,px=f) (fays y (Found idp))
  }
  | y :: xs, ys, SkipSublist sub => mcases \with {
    | true => SkipSublist (filter-max sub fays)
    | false => filter-max sub fays
  }

-- 2. Докажите, что Perm l1 l2 тогда и только тогда, когда Insertion.sort l1 = Insertion.sort l2.

-- 3. Докажите, что спецификация "результат является перестановкой входа и отсортирован" является полной для функции sort.

\func completeness {A : Dec} (sort : List A -> List A) (l : List A) (p : Perm l (sort l)) (s : Sorted (sort l)) : sort l = Insertion.sort l
  => {?}

-- 4. Определите факториал через хвостовую рекурсию.
--    Докажите, что он равен обычному определению факториала.

-- 5. Функция isBalanced проверяет правильность скобочной последовательности.
--    Докажите ее корректность.

\data Paren | Left | Right

\func isBalanced (xs : List Paren) : Bool
  => aux xs 0
  \where {
    \func aux (xs : List Paren) (p : Nat) : Bool \elim xs, p
      | nil, 0 => true
      | nil, suc _ => false
      | Left :: xs, p => aux xs (suc p)
      | Right :: xs, 0 => false
      | Right :: xs, suc p => aux xs p
  }

\data Balanced (xs : List Paren) \with
  | nil => nil-balanced
  | :: Left xs => cons-balanced {ys : List Paren} (Balanced ys) (xs = ys ++ Right :: nil)
  | xs => append-balanced {ys zs : List Paren} (Balanced ys) (Balanced zs) (xs = ys ++ zs)

\func isBalanced-correct (xs : List Paren) : (isBalanced xs = true) <-> Balanced xs
  => {?}
