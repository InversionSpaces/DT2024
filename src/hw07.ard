\import Data.Maybe
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import hw01 (gcd)
\import lect07
\open Nat(+)

-- 1. Определите функцию swap несколькими способами.

-- При помощи \cowith и доступа к полям.
\func swap {A B : \Type} (p : Pair A B) : Pair B A \cowith
  | fst_ => p.snd_
  | snd_ => p.fst_

-- При помощи \new и паттерн матчинга.
\func swap' {A B : \Type} (p : Pair A B) : Pair B A =>
  \case p \with {
    | (a, b) => \new Pair B A b a
  }

-- При помощи \new и доступа к полям.
\func swap'' {A B : \Type} (p : Pair A B) : Pair B A =>
  \new Pair B A p.snd_ p.fst_

-- 2. Докажите, что swap (swap p) = p.

\func swap-involutive {A B : \Type} (p : Pair A B) : swap (swap p) = p => idp

-- 3. Докажите, что тип PosNat 0 пустой, а тип PosNat 1 нет.

\func zero-isNotPos (p : PosNat 0) : Empty => p.p

\func one-isPos : PosNat 1 => \new PosNat 1 ()

-- 4. Определите \record, состоящий из пар взаимно простых натуральных чисел.
--    Определите тип, состоящий из натуральных чисел, взаимно простых с 60.

\record CoprimePair (a b : Nat) (proof : gcd a b = 1)

\func Comprime60 : \Type => CoprimePair { | b => 60 }

-- 5. Закончите определение класса монад. Этот класс должен содержать все монадные законы и реализовывать все поля из класса функторов.

\class Monad \extends Functor
  | return {A : \Set} : A -> F A
  | \infixl 1 >>= {A B : \Set} : F A -> (A -> F B) -> F B
  | return-left-id {A B : \Set} (x : A) (f : A -> F B) : (return x >>= f) = f x
  | return-right-id {A : \Set} (x : F A) : (x >>= return) = x
  | bind-assoc {A B C : \Set} (x : F A) (f : A -> F B) (g : B -> F C) : (x >>= (\lam a => f a >>= g)) = (x >>= f >>= g)
  | Functor.fmap f => \lam fa => fa >>= (\lam a => return (f a))
  | Functor.fmap-id => return-right-id
  | Functor.fmap-comp f g x =>  \let fr => \lam a => return (f a)
                                     | gr => \lam a => return (g a)
                                     | assoc => bind-assoc x fr gr
                                     | rli => path (\lam i => \lam a => return-left-id (f a) gr @ i)
                                     | bindx => pmap (>>= x) rli
                                     | result => rewrite assoc bindx
                                \in inv result

-- 6. Определите \instance Monad для Maybe.

\instance MaybeMonad : Monad Maybe => {?}

-- 7. Определите \instance Monad для State и State'.

\record State (S A : \Type)
  | state : S -> \Sigma S A

\data State' (S A : \Type)
  | state' (S -> \Sigma S A)
